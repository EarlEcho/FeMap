# 闭包 —— 大boss

闭包的前置知识肯定是作用域啦：👉🏻[作用域](./actionScope.md "作用域")

闭包的重要性不言而喻，那么到底什么是闭包呢？这个概念只要是本Javascript基础的书里面都会写到，但是他们的定义描述都有点不尽相同。

* 闭包是指有权访问另一个函数作用域中的变量的函数；——《JavaScript高级程序设计》

* 从技术的角度讲，所有的JavaScript函数都是闭包：它们都是对象，它们都关联到作用域链。 —— 《JavaScript权威指南》

* 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 —— 《你不知道的JavaScript》

其实闭包是基于词法作用域书法代码时产生的自然结果，这是一种现象，闭包可能在我们平时写的代码里随处可见，知识可能我们自己都不知道这一段代码就产生了闭包

## 详解闭包

我们已经知道 —— 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

看个例子：

``` js
function f1() {
    var name = 'Echo';

    function f2() {
        console.log(name):
    }
    f2();
}
f1();
```

如果按照《JavaScript高级程序设计》和《JavaScript权威指南》中的定义，上面的代码已经产生了闭包，因为 `f2()` 访问到了 `f1()` 中的变量，满足了 `访问另一个函数作用域中的变量的函数` 这一条件，而 `f2()` 是个函数，满足了 `所有的JavaScript函数都是闭包` 。
其实这也确实是闭包，只是这种闭包不是太好观察
我们再来看一个例子：

``` js
function fn1() {
    var name = 'Echo';

    function fn2() {
        console.log(name);
    }
    return fn2;
}
var fn3 = fn1();
fn3();
```

这样就清晰的展示了闭包：

1. fn2的词法作用域能访问fn1的作用域
2. 将fn2当作一个值返回
3. fn1执行后，将fn2的引用赋值给fn3
4. 执行fn3，输出变量name

通过引用的关系，fn3就是fn2函数本身。执行fn3能正常输出name，这不就是fn2能记住并访问它所在的词法作用域，而且fn2函数的运行还是在当前词法作用域之外了。

正常来说，当fn1函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却很神奇的将fn1的作用域存活了下来，fn2依然持有该作用域的引用，这个引用就是闭包。

所以总结一下：**某个函数在定义的词法作用域之外被调用，闭包可以使该函数极限访问定义时的词法作用域**

虽然上面的例子和说法比较的书面化，但是闭包绝对不是一个无用的概念，我们平时的代码里多少都有出现过闭包的身影。
一个比较经典的例子就是定时器延时打印：

``` js
for (let i = 0; i < 10; i++) {
    setTimeout(function() => {
        console.log(i);
    }, 1000);
}
```

上面这个例子我们期望的是输出 `0～9` ，但是实际结果是最终会打印出 `10次9` ，这是因为 `setTimeout` 中的匿名函数执行时， `for` 循环都已经结束了，所以最终就是输出 `10次9` .

至于原因： `i` 是声明在全局作用域中的，定时器中的匿名函数也是执行在全局作用域中，所以每次都会输出9.

原因知道了，如何解决就知道了，我们可以让 `i` 在每次迭代时，都产生一个私有作用域，在这个私有的作用域中保存当前值。

``` js
for (let i = 0; i < 10; i++) {
    (function() {
        var j = i;
        setTimeout(function() {
            console.log(j);
        }, 1000);
    })();
}
```

看，像上面这样就达到了我们想要的结果，只是看上去不是很优雅的写法，我们可以改造一些，将每次迭代的i作为实参传递给自执行函数，自执行函数中用变量去接收：

``` js
for (var i = 1; i <= 10; i++) {
    (function(j) {
        setTimeout(function() {
            console.log(j);
        }, 1000);
    })(i);
}
```

## 四. 闭包的应用

闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部：

``` js
function module() {

    var arr = [];

    function add(val) {
        if (typeof val == 'number') {
            arr.push(val);
        }
    }

    function get(index) {
        if (index < arr.length) {
            return arr[index]
        } else {
            return null;
        }
    }
    return {
        add: add,
        get: get
    }

}
var mod1 = module();
mod1.add(1);
mod1.add(2);
mod1.add('xxx');
console.log(mod1.get(2));
```

