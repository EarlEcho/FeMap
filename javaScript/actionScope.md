# 闭包前置知识 —— 作用域和词法作用域

首先我们需要知道一个概念： `词法作用域是作用域的一种工作模型` 

所以从上面这个句话我们就可以得出一个结论 —— `没有作用域的概念就没有词法作用域的概念` 
所以我们步入正题：什么是作用域

## 一. 什么是作用域

定义：作用域就是一套规则，用于确定在何处以及如何查找变量的规则。

来看两个例子：

``` js
//  例子1
function foo() {
    var a = 'EchoA';
    console.log(a);
}
foo();
```

``` js
// 例子2
var b = 'EchoB';

function foo() {
    console.log(a);
}
foo();
```

上面这两个例子我们可以很容易的知道：
例子1 —— 在函数作用域中找到变量a
例子2 —— 在全局作用域中找到变量b

所以其实作用域就是查找变量的地方，我们在查找b变量的时候，先在函数作用域中查找，没有找到，再去全局作用域中查找，有一个往外层查找的过程。我们好像是顺着一条链条从下往上查找变量，这条链条，我们就称之为 `作用域链` 。

## 二. 作用域中变量的查找规则

我们都知道JavaScrip是有编译过程的，比如说我们定义一个变量：
` var str = 'hello'; ` 
这一句话其实是有两个编译动作的：

1. 编译器在当前作用域中声明一个变量str
2. 运行时引擎在作用域中查找这个变量，找到了str并为其赋值'hello'

我们现在可以来证实一下我们的上面的说法：

``` js
console.log(str); // undefined
var str = 'hello';
```

在 `var str = 'hello'; ` 的上一行输出str变量，并没有报错，输出undefined，说明输出的时候该变量已经存在了，只是没有赋值而已。

其实编译器是这样工作的：**在代码执行之前从上到下的进行编译，当遇到某个用var声明的变量的时候，先检查在当前作用域下是否存在了该变量。如果存在，则忽略这个声明；如果不存在，则在当前作用域中声明该变量。**

## 三. 词法作用域

所谓的词法作用域就是：**在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了。并且是逐级包含的**

* eval()和with可以通过其特殊性用来“欺骗”词法作用域，不过正常情况下都不建议使用，会产生性能问题。
* ES6中有了let、const就有了块级作用域，之后详解。

